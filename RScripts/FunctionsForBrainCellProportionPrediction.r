## Main script by Eilis Hannon, adapted by Dorothea Seiler Vellame
## functions for estimate cell counts edited to take matrices rather than mset
library(genefilter)
library(quadprog)

validationCellType <- function(Y, pheno, modelFix, modelBatch=NULL,
                               L.forFstat = NULL, verbose = FALSE){
  N <- dim(pheno)[1]
  pheno$y <- rep(0, N)
  xTest <- model.matrix(modelFix, pheno)
  sizeModel <- dim(xTest)[2]
  M <- dim(Y)[1]

  if(is.null(L.forFstat)) {
    L.forFstat <- diag(sizeModel)[-1,] # All non-intercept coefficients
    colnames(L.forFstat) <- colnames(xTest)
    rownames(L.forFstat) <- colnames(xTest)[-1]
  }

  ## Initialize various containers
  sigmaResid <- sigmaIcept <- nObserved <- nClusters <- Fstat <- rep(NA, M)
  coefEsts <- matrix(NA, M, sizeModel)
  coefVcovs <- list()

  if(verbose)
    cat("[validationCellType] ")
  for(j in 1:M) { # For each CpG
    ## Remove missing methylation values
    ii <- !is.na(Y[j,])
    nObserved[j] <- sum(ii)
    pheno$y <- Y[j,]

    if(j%%round(M/10)==0 && verbose)
      cat(".") # Report progress

    try({ # Try to fit a mixed model to adjust for plate
      if(!is.null(modelBatch)) {
        fit <- try(lme(modelFix, random=modelBatch, data=pheno[ii,]))
        OLS <- inherits(fit,"try-error") # If LME can't be fit, just use OLS
      } else
        OLS <- TRUE

      if(OLS) {
        fit <- lm(modelFix, data=pheno[ii,])
        fitCoef <- fit$coef
        sigmaResid[j] <- summary(fit)$sigma
        sigmaIcept[j] <- 0
        nClusters[j] <- 0
      } else {
        fitCoef <- fit$coef$fixed
        sigmaResid[j] <- fit$sigma
        sigmaIcept[j] <- sqrt(getVarCov(fit)[1])
        nClusters[j] <- length(fit$coef$random[[1]])
      }
      coefEsts[j,] <- fitCoef
      coefVcovs[[j]] <- vcov(fit)

      useCoef <- L.forFstat %*% fitCoef
      useV <- L.forFstat %*% coefVcovs[[j]] %*% t(L.forFstat)
      Fstat[j] <- (t(useCoef) %*% solve(useV, useCoef))/sizeModel
    })
  }
  if(verbose)
    cat(" done\n")
  ## Name the rows so that they can be easily matched to the target data set
  rownames(coefEsts) <- rownames(Y)
  colnames(coefEsts) <- names(fitCoef)
  degFree <- nObserved - nClusters - sizeModel + 1

  ## Get P values corresponding to F statistics
  Pval <- 1-pf(Fstat, sizeModel, degFree)

  out <- list(coefEsts=coefEsts, coefVcovs=coefVcovs, modelFix=modelFix, modelBatch=modelBatch,
              sigmaIcept=sigmaIcept, sigmaResid=sigmaResid, L.forFstat=L.forFstat, Pval=Pval,
              orderFstat=order(-Fstat), Fstat=Fstat, nClusters=nClusters, nObserved=nObserved,
              degFree=degFree)

  out
}


pickCompProbes <- function(rawbetas, cellInd, cellTypes = NULL, numProbes = 50, probeSelect = probeSelectIN) {
  ## p is matrix of beta values
  ## cellInd is vector denoting cell type
  splitit <- function(x) {
    split(seq(along=x), x)
  }

  #   p <- getBeta(mSet)
  #   pd <- as.data.frame(colData(mSet))
  if(!is.null(cellTypes)) {
    if(!all(cellTypes %in% as.character(cellInd)))
      stop("elements of argument 'cellTypes' is not part of 'cellInd'")
    keep <- which(as.character(cellInd) %in% cellTypes)
    rawbetas <- rawbetas[,keep]
    cellInd<-cellInd[keep]
  }
  ## make cell type a factor
  cellInd <- factor(cellInd)
  ffComp <- rowFtests(rawbetas, cellInd)
  prof <- sapply(splitit(cellInd), function(i) rowMeans(rawbetas[,i]))
  r <- matrixStats::rowRanges(rawbetas)
  compTable <- cbind(ffComp, prof, r, abs(r[,1] - r[,2]))
  names(compTable)[1] <- "Fstat"
  names(compTable)[c(-2,-1,0) + ncol(compTable)] <- c("low", "high", "range")
  tIndexes <- splitit(cellInd)
  tstatList <- lapply(tIndexes, function(i) {
    x <- rep(0,ncol(rawbetas))
    x[i] <- 1
    return(rowttests(rawbetas, factor(x)))
  })

  if (probeSelect == "any"){
    probeList <- lapply(tstatList, function(x) {
      y <- x[x[,"p.value"] < 1e-8,]
      yAny <- y[order(abs(y[,"dm"]), decreasing=TRUE),]
      c(rownames(yAny)[1:(numProbes*2)])
    })
  } else {
    probeList <- lapply(tstatList, function(x) {
      y <- x[x[,"p.value"] < 1e-8,]
      yUp <- y[order(y[,"dm"], decreasing=TRUE),]
      yDown <- y[order(y[,"dm"], decreasing=FALSE),]
      c(rownames(yUp)[1:numProbes], rownames(yDown)[1:numProbes])
    })
  }

  trainingProbes <- na.omit(unique(unlist(probeList)))
  rawbetas <- rawbetas[trainingProbes,]

  pMeans <- colMeans(rawbetas)
  names(pMeans) <- cellInd

  form <- as.formula(sprintf("y ~ %s - 1", paste(levels(cellInd), collapse="+")))
  phenoDF <- as.data.frame(model.matrix(~cellInd-1))
  colnames(phenoDF) <- sub("cellInd", "", colnames(phenoDF))
  if(ncol(phenoDF) == 2) { # two group solution
    X <- as.matrix(phenoDF)
    coefEsts <- t(solve(t(X) %*% X) %*% t(X) %*% t(rawbetas))
  } else { # > 2 group solution
    tmp <- validationCellType(Y = rawbetas, pheno = phenoDF, modelFix = form)
    coefEsts <- tmp$coefEsts
  }

  out <- list(coefEsts = coefEsts, compTable = compTable,
              sampleMeans = pMeans)
  return(out)
}


projectCellTypeWithError = function(YIN, coefCellTypeIN, sampleDup = 0){
  
  ## if there's only 1 sample, pretend there are 2 so it doesn't break
  if (ncol(as.matrix(YIN)) == 1){ 
    sampleDup = 1
    YIN = cbind(YIN, YIN)
  }
  
  
  projectCellType <- function(Y, coefCellType, contrastCellType=NULL, nonnegative=TRUE, lessThanOne=FALSE){ 
    if(is.null(contrastCellType))
      Xmat <- coefCellType
    else
      Xmat <- tcrossprod(coefCellType, contrastCellType) 
    
    nCol <- dim(Xmat)[2]
    if(nCol == 2) {
      obs <- which(apply(Y, 1, function(x){return(sum(is.na(x)) == 0)}))
      Dmat <- crossprod(Xmat[obs,])
      mixCoef <- t(apply(Y, 2, function(x) { solve(Dmat, crossprod(Xmat[obs,], x[obs])) }))
      colnames(mixCoef) <- colnames(Xmat)
      return(mixCoef)
    } else {
      nSubj <- dim(Y)[2]
      
      mixCoef <- matrix(0, nSubj, nCol)
      rownames(mixCoef) <- colnames(Y)
      colnames(mixCoef) <- colnames(Xmat)
      
      if(nonnegative){
        if(lessThanOne) {
          Amat <- cbind(rep(-1, nCol), diag(nCol))
          b0vec <- c(-1, rep(0, nCol))
        } else {
          Amat <- diag(nCol)
          b0vec <- rep(0, nCol)
        }
        for(i in 1:nSubj) {
          obs <- which(!is.na(Y[,i])) 
          Dmat <- crossprod(Xmat[obs,])
          mixCoef[i,] <- solve.QP(Dmat, crossprod(Xmat[obs,], Y[obs,i]), Amat, b0vec)$sol
        }
      } else {
        for(i in 1:nSubj) {
          obs <- which(!is.na(Y[,i])) 
          Dmat <- crossprod(Xmat[obs,])
          mixCoef[i,] <- solve(Dmat, t(Xmat[obs,]) %*% Y[obs,i])
        }
      }
      return(mixCoef)
    }
  }
  
  ## error function
  getErrorPerSample = function(applyIndex,
                               predictedIN = mixCoef,
                               coefDataIN = coefCellTypeIN,
                               betasBulkIN = YIN){
    
    trueBulk = matrix(ncol = 1, nrow = nrow(coefDataIN), data = 0)
    
    RMSE = function(m, o){
      sqrt(mean((m - o)^2))
    }
    
    for (i in 1:ncol(coefDataIN)){
      
      trueBulk[,1] = trueBulk[,1] + coefDataIN[,i]*predictedIN[applyIndex,i]
    }
    
    betasBulkIN = t(apply(betasBulkIN, 1, function(x){x[is.na(x)] = 0; return(x)}))
    
    error = RMSE(trueBulk, betasBulkIN[,applyIndex])
    return(error)
  }
  
  mixCoef = projectCellType(YIN, coefCellTypeIN)
  error = sapply(1:nrow(mixCoef), getErrorPerSample)
  nCGmissing = apply(YIN, 2, function(x){sum(is.na(x))})
  mixCoef = cbind(mixCoef, error, nCGmissing)
  
  if (sampleDup == 1){
    mixCoef = mixCoef[1,]
  }
  
  return(mixCoef)
  
}


loadModelData = function(modelType = c("mouseHumanHybrid", "mouse")){
    load(paste("models/", modelType, "Model.Rdata", sep = ""))
}
